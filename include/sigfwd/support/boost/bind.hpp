// Copyright 2010 Edd Dawson.
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_BIND_HPP_2328_05072010
#define BOOST_BIND_HPP_2328_05072010

#include <sigfwd/functor_traits.hpp>

#include <boost/bind.hpp>
#include <boost/type_traits/remove_pointer.hpp>
#include <boost/type_traits/is_function.hpp>

#include <boost/mpl/vector.hpp>
#include <boost/mpl/at.hpp>
#include <boost/mpl/find.hpp>
#include <boost/mpl/max.hpp>
#include <boost/mpl/int.hpp>
#include <boost/mpl/fold.hpp>
#include <boost/mpl/range_c.hpp>
#include <boost/mpl/placeholders.hpp>

#include <boost/preprocessor/iteration/local.hpp>
#include <boost/preprocessor/repetition/enum_params.hpp>
#include <boost/preprocessor/cat.hpp>
#include <boost/preprocessor/arithmetic/sub.hpp>

// Support for boost::bind
// -------------------------
//
// This is somewhat involved, so it's probably worth spelling things out in detail. Given a function:
//
//   float foo(int, double, bool);
//
// the expression:
//
//   boost::bind(&foo, 42, _2, _1) 
//
// produces an object of type:
//
//   boost::_bi::bind_t<
//      float, 
//      float (*)(int, double, bool), 
//      boost::_bi::list3<boost::_bi::value<int>, boost::arg<2>, boost::arg<1> > 
//   >
//
// The 2nd template argument in that bind_t type is the signature of the function we're binding. It typically has more
// arguments that the functor generated by bind. The 3rd template argument has encoded within it the indices in to the
// parameter list in that 2nd argument of the types of the resulting function object's parameters.
//
// So here's what we do:
//
// 1. Get a boost::mpl Sequence of the types in that 3rd argument. This is a bit of a slog, but we can use the boost
//    preprocessor library to generate a meta-function that's specialized for boost::_bi::list0, ..., list8.
//    This series of meta-functions is called bind_list_to_mpl, below. We'll call this mpl Sequence bound_params.
//
// 2. Use boost::function_types::parameter_list to get another mpl Sequence of the parameter types in 
//    boost::_bi::bind_t's 2nd argument. We'll call this mpl Sequence unbound_params.
//
// 3. Find the largest X such that boost::arg<X> appears in the mpl sequence we made in step 1. This is the value for 
//    "arity" in our functor_traits specialization and is found with the max_placeholder function, below.
//
// 4. Pseudo-code for constructing the "params" type in our functor_traits specialization:
//
//    params = []
//    for(i = 1; i <= arity; ++i)
//       k = index of boost::arg<i> in bound_params // see find_bind_ph meta-function, below
//       t = type of unbound_params[k]
//       params.append(t)
//
// Of course, we can't construct params using a for-loop, but we can get mpl::fold to do the job. See the compose_params
// meta-function, below.
//
// Now for the member function case(!)
//
// Given:
//
//   struct C
//   {
//       float foo(int, double, bool);
//   };
//   C c;
//
// the expression:
//
//   boost::bind(&C::foo, &c, 42, _2, _1);
//
// produces an object of type:
//
//   boost::_bi::bind_t<
//      float, 
//      boost::_mfi::mf3<float, C, int, double, bool>,
//      boost::_bi::list4<boost::_bi::value<C*>, boost::arg<1>, boost::_bi::value<double>, boost::_bi::value<bool> >,
//   >
//
// The procedure is the same as in the non-member-function case, except that in step 2 we're having to create an 
// mpl Sequence from a boost::_mfi::mf<N> type rather than a function pointer. Again we use the preprocessor library
// to create the meta-functions (one for each value of <N>) needed to extract this sequence. These meta-functions are
// named mf_list_to_mpl in the code below.

namespace sigfwd
{
    namespace impl
    {
        namespace mpl = ::boost::mpl;

        template<typename BindList>
        struct bind_list_to_mpl;

        template<>
        struct bind_list_to_mpl<boost::_bi::list0> { typedef mpl::vector<> type; };

#define BOOST_PP_LOCAL_MACRO(n) \
        template<BOOST_PP_ENUM_PARAMS(n, typename T)> \
        struct bind_list_to_mpl<boost::_bi:: BOOST_PP_CAT(list, n) <BOOST_PP_ENUM_PARAMS(n, T)> > \
        { \
            typedef mpl::vector<BOOST_PP_ENUM_PARAMS(n, T)> type; \
        };

#define BOOST_PP_LOCAL_LIMITS (1, 8)
#include BOOST_PP_LOCAL_ITERATE()

        template<typename MFList>
        struct mf_list_to_mpl;

#define BOOST_PP_LOCAL_MACRO(n) \
        template<typename R, BOOST_PP_ENUM_PARAMS(n, typename T)> \
        struct mf_list_to_mpl<boost::_mfi:: BOOST_PP_CAT(mf, BOOST_PP_SUB(n,1)) <R, BOOST_PP_ENUM_PARAMS(n, T)> > \
        { \
            typedef mpl::vector<BOOST_PP_ENUM_PARAMS(n, T)> type; \
        };

#define BOOST_PP_LOCAL_LIMITS (1, 8)
#include BOOST_PP_LOCAL_ITERATE()

        template<typename T>
        struct is_ph : mpl::int_<boost::is_placeholder<T>::value> { }; // proper integral metafunction

        template<typename BoundParams>
        struct max_placeholder : mpl::fold<BoundParams, mpl::int_<0>, mpl::max<mpl::_1, is_ph<mpl::_2> > >::type { };
        
        template<typename BoundParams, typename T>
        struct find_bind_ph : mpl::find<BoundParams, boost::arg<T::value + 1> >::type::pos { };

        template<std::size_t Arity, typename BoundParams, typename UnboundParams>
        struct compose_params :
            mpl::fold
            <
                mpl::range_c<int, 0, Arity>, 
                mpl::vector<>, 
                mpl::push_back<mpl::_1, mpl::at<UnboundParams, find_bind_ph<BoundParams, mpl::_2> > >
            >
        {
        };

    } // close namespace impl


    // Specialization for boost::bind
    template<typename R, typename FullSig, typename List>
    struct functor_traits<boost::_bi::bind_t<R, FullSig, List> >
    {
        typedef typename impl::bind_list_to_mpl<List>::type bound_params;
        static const std::size_t arity = impl::max_placeholder<bound_params>::value;

        typedef typename boost::remove_pointer<FullSig>::type full_sig; // function pointer -> function

        typedef typename boost::mpl::if_
        <
            typename boost::is_function<full_sig>::type,      // if we're binding a function/function pointer,
            boost::function_types::parameter_types<full_sig>, // then extract parameter types via boost::function_types
            impl::mf_list_to_mpl<full_sig>                    // else use mf_list_to_mpl
        >
        ::type unbound_params;
        typedef typename impl::compose_params<arity, bound_params, typename unbound_params::type>::type params;
    };

} // close namespace sigfwd

#endif // BOOST_BIND_HPP_2328_05072010
